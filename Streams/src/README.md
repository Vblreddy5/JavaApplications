# JavaApplications
Functional programming
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Let's talk about a programming paradigm you've probably heard of, Functional Programming. This programming paradigm is becoming increasingly popular. Let's use Java and explore how it can improve our code. Functional Programming is a programming paradigm that treats computations as the evaluation of mathematical functions. It focuses on the use of immutable data, whilst avoiding changing state immutable data. In functional programming, functions are first-class citizens. This means that it can be assigned to variables, passed as arguments, and returned from other functions. There are a number of benefits to functional programming that make it worth incorporating this programming style to your toolbox. First of all, it's easier to understand and therefore easier to debug. Functional programming aims on working with immutable data and not changing state. With no shared state and side effects, the code becomes more predictable. It's easy to understand what's going on and that helps for debugging. The next point is that functional programming enhances modularity. It promotes composing smaller functions into more complex ones, making the code more modular and easier to maintain. And lastly, it leads to improved concurrency. In case you're not familiar with a concept, concurrency means that multiple things can be going on at the same time, as functional programming avoids multiple state. It makes it simpler to write concurrent and parallel code, so there aren't going to be any funky side effects in other threats. Java 8 introduced several features that enable functional programming, including Lambda Expressions, method references, and the stream API. We're going to discuss these concept next. Let's dive into Lambda expressions in the next video to see how we can start implementing functional programming in our Java projects.

Lambda expressions
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Now that we understand the concept of functional programming, let's dive into lambda expressions. They're one of the main building blocks of functional programming. A lambda expression is a short anonymous function that can be used to implement functional interfaces. What are functional interfaces, you may wonder? Well, these are interfaces with only one abstract method. The syntax for lambda expressions consists of three parts. We have the parameter list. These are the input parameters for the lambda function and closed in parentheses. These parentheses can be omitted if there's only one parameter. Then we have the arrow token. It's the hyphen symbol followed by a bigger than symbol, which separates the parameter list from the body. And the body is the third part. The lambda function body can be a single expression or a block of code enclosed in curly braces. If it's a single statement, the curly braces can be omitted. This is an example of a lambda expression that takes two integers and returns their sum. This means there needs to be a functional interface with an abstract method with a corresponding signature. So two input arguments and returning something of that same type. For example, the one that you can see on the slide it returns an int and takes two ints as input. This might sound somewhat vague. So let's have a look at an example in IntelliJ. On line seven, you can see a predicate. A predicate is a built-in functional interface that takes an argument and returns a Boolean. So for example, here we create a predicate to determine whether a string is larger than five characters. The predicate is an interface with one abstract method. Let me show you the predicate here. As you can see, it is one abstract method called Test that returns Boolean. That's why we can use our newly created implementation like this largerThan5.test the name of the method and then insert the input, in this case, Hello. And if I'm going to catch this result and print it it's going to be false, because Hello has five characters exactly, and that's why the length is not longer than five. Lambda expressions can be assigned to variables or passed as arguments to methods. Let's create an example of using a lambda expression with a build-in functional interface called Consumer. The building Consumer takes a parameter and returns nothing. So in this case, lambda expression is having some parameters that are then being used to print something. No value is being returned. In this case, I can omit parentheses, 'cause I only have one input parameter. And I'm just going to say that it's going to print it in uppercase. The abstract method is called Accept, and that's why I can call it like this. And I can run this. So you can see I have assigned two lambda expressions, two variables. I have a variable LargerThan5 calling it Predicate and I have a printUpperCase variable calling it Consumer. I could even go ahead and create another method called doSomething, and this method is going to accept a predicate. In order to call this method, I need to pass in a predicate. And inside this method, I'm then going to just call the test method on the predicate and return the result. So this could be testing for anything and in this case it's testing for larger than five, because that's the one I'm having. So let's go ahead and call the method. And this is now going to print through at the variant, because doSomething is larger than five characters. I could also call my doSomething with a different lambda expression. And I don't need to sort this in a variable first. I can also just go ahead and implement a lambda expression on the spot here. So right now I'm going to check for whether it starts with an A or not. And this is going to return false, because doSomething does not start with an uppercase A. As you can see, this is making my code very dynamic. So there's one more thing I need to tell you about lambda expressions. There's a shorthand syntax called Method Reference. When we use a lambda expression to trigger another existing method we can write this in a shorter way namely with a Method Reference. This can only be used for existing methods. It has a different syntax with double colon and there are some variations on how to do it, but we could write our previous example of the consumer with two uppercase instead. If we had a lambda expression that would be s becomes s.ToUppercase. We could write this like String::toUpperCase. We don't need to specify the input parameters. It knows and it takes a string as input and returns the string as output. So far, this might not seem too useful. We use lambda expressions a lot combined with the Stream API. In the next video we'll explore the Stream API. This will help us better handle and process data sets in a functional programming style.

Streams API and handling data sets
Selecting transcript lines in this section will navigate to timestamp in the video
- The Stream API allows us to process and manipulate datasets using a functional programming approach and it can simplify our code when handling datasets. Let's start with Streams. What are these? A Stream is a sequence of elements that can be processed sequentially or in parallel. Streams have a source. They can be created in various ways using a Stream API. You can create a Stream from various sources such as collections, arrays, or I/O channels. Here are some examples. On line 12, I created a Stream using the list I created on line 11. I can simply do this with the .stream() method. I can also create a Stream from an array. This is a slightly different approach. You can see in line 15, I'm creating an array and then on line 16, I'm using the .stream() method on the arrays helper class to actually turn this into a Stream. And I can also create a Stream with the Stream.of method that I'm using online 19. There's actually quite a few more ways to create a Stream but these are some common source operations that we can use. After we have created the Stream, we could do multiple things with it. There's distinction between intermediate and terminal operations. The intermediate operations can be chained and all of these return a new Stream. When you perform a terminal operation, the Stream ends and no other operation can be performed on it anymore. Intermediate operations are lazy. They don't execute until a terminal operation is called. Let's explore some common intermediate and terminal operations. First, intermediate operations. A very common one is the filter. This filters element is based on a predicate. We also have the map and this transforms elements using a given function and a function is a type of build-in functional interface here. Then we also have the flatMap. This transforms each element into a Stream and then flattens the resulting Streams into a single Stream. There are quite a few more, but this video doesn't intend to cover all of them. I just want to give you a quick introduction or recap. So let's see, some terminal operations. We have the forEach operation, and that's going to apply an action to each element in the Stream, literally for each. Then we also have to collect. This is going to get all the elements of the Stream and collect some into a collection such as a list or a set. And then we also have reduce. This reduces the Stream to a single value using an accumulator function. Again, there are a lot more options and you'll find them when you need them. This is just a quick introduction or recap, depending on where you are currently standing. Let's look at some examples in IntelliJ In this example, I filtered the names starting with "A", transform them to uppercase and then go ahead and put them in a list. I stored these in the variable filterdNames and then I'm printing them. Let's see the results, and as you can see this is printing results, Ali and Adam. And yes, this could have been done differently with loops and if statements as well. We have now achieved our goal in a functional programming style that is typically preferred. Great. Now you have the background knowledge to start writing code in the functional programming style.

Solution: Java streams and lambda expressions
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] All right, let's have a look at our solution. So, we needed to find the highest grade for students with a specific major. Here's how to implement the defined answer, to do exactly that. You can see the answer on line 17 'till 20. Defined answer receives a list of students and we start by turning this list into a stream. Then, we filter based on the major that was passed in. Next, we flatten the streams of grades to one single stream, and then we find the max integer. If no value is being found, we return zero. And we do so by implementing the supplier that simply says, return zero. And then as you can see, when we run this code, it says, "Correct: Marvelous work." So, let's demonstrate this again. Another one solved. Well, if we were to update a major to, for example mathematics, we'll get a different result, or at least we could get a different result. So let's run this code and you'll see the answer. And you can see the highest grade is now 89. There are no other majors to try, but if we try something that doesn't exist, for example biology, it's just going to return zero.

Java collection framework
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Let's talk about the Java collection framework. It provides a wide range of data structures for handling collections of objects. We'll discuss the main interfaces and some of their implementations. The Java collection framework consists of several interfaces and classes that represent different types of collections. The main interfaces are list, set, queue and map. These interfaces define common operations such as adding, removing, or iterating over elements. The interfaces list, set and queue extend to collection interface. Map is a bit of an odd one. It doesn't extend to collection interface. This is because it's quite different from the others. It worked with key value pairs instead of single values. There are also implementation classes. These classes have implementations that provide specific behaviors and performance characteristics for the data structure. We're going to focus on the most used interfaces and leave out a queue interface for that reason. Here are the most commonly used interfaces; list, which is an ordered collection that allows duplicates, set, which is a collection that doesn't allow duplicates and map, which is a collection that maps keys to values. There are many implementations. I just want to talk you through a few of the most common ones. So for example, we have ArrayList, which is a resizable array-based implementation of the list interface. There's also a LinkList, which is a doubly linked list implementation of the list interface. And we have HashSet, a hash table-based implementation of the set interface. And there are more. We have the TreeSet, which is a balanced binary tree-based implementation of the set interface. The HashMap, which is a hash table-based implementation of the map interface. And the last one I'm going to mention is the TreeMap, which is a balanced binary tree-based implementation of the map interface. No worries, I'm not going to walk you through all of these examples. I just want to show you a basic one. Here's an ArrayList, and I'm performing some basic operations on it. So I create the array list on line eight and as you can see, it's the convention to make it of the type of the interface, list, in this case. On line nine, 10, and 11, I'm adding names to the ArrayList with the add method. On line 12, I'm removing. In line 13, I'm just printing the list. You can see that I set it would be a list of strings on line eight. In this way, the compiler can check whether I'm only adding the right type to our list. And this prevents a lot of problems. That I can specify the type is achieved with use of generics. In the next video, we're going to have a look at generics in more detail.

Role of generics
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] It's time to take a step back and explore what generics are by looking at the role of generics and their advantages. Let's start with a little history. Before generics were introduced in Java, collections would only store objects of type Object. This meant that you had to cast objects to the correct type when retrieving them from a collection. And if you try to cast something that couldn't be done, you'd get a lovely runtime exception to inform you. Generics address this issue by allowing us to specify the type of objects a collection can hold at compile time. And this brings us the some advantages of generics. Collections with generics eliminate the need for casting and improves type safety. Here are some advantages of working with generics. First of all, type safety. Generics help to catch type-related errors at compile time rather than at runtime. And it also has a reusability component. Generic classes and interfaces can be reused with different types, reducing duplicate code. Let's have a look at another example. This time, a list of integers. As you can see, I'm adding numbers to the list. What I cannot do, is add a non-number to the list or a non-integer to be more specific. For example, I cannot say 'hello'. Why not? Because hello is not an integer and the compiler knows this. The required type is an integer, but provided, is a string. What we can also not do, is for example, add a long, like this. Because again, the required type is an integer. But this time, we provided a long. And in the same way, when we take a value off our list, it knows it's an integer and that's why we can use it for summing, as we're doing on line 13, 14, and 15. We're done printing outputs, and when we add all these numbers, we get the output: Sum 6. Generics play an essential role in Java, providing type safety and code reusability. Let's have a look at how to obtain this code reusability by writing our own classes with the use of generics.

Creating and using classes with parameterized types
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Classes that use generics are called classes with parameterized types. In this video, we'll learn how to create and use classes with parameterized types. This way we can benefit from generics if we need to for our own classes and interfaces. Besides, it will help us to understand built-in codes that uses it even better. To create a generic class, you need to define one or more type parameters within angle brackets. This goes in a class declaration. These type parameters can be used within the class as placeholders for the actual types that will be used when creating instances of the class. Let's see how we can benefit from generics in IntelliJ. So here I have a special class String pair with two properties, both have type String. They're called first and second and actually, I also want to have an Integer pair. But in order to have an Integer pair without generics I need to have two classes. One called String pair, one called Integer pair. Alternatively, I could make one class with type object but that would not be type safe. That's where generics come into play. Here is a simple generic pair class that can hold two objects of the same type. T is the parameterized type. As you can see, I'm using it as a type throughout this class. On line four and five, I'm saying I have two properties, first and second of type T. And for example, my getFirst on line 12 is returning T. After creating the generic class we can use it upon creation. We need to provide the actual type arguments. This specifies the type that the type parameter represents allowing the compiler to enforce type safety. Let's move back to IntelliJ and see it as an action for our example. So, here's a main class and it has a main method. On line five and six, I'm creating two objects of type pair. 

Solution: Refactor to parameterized type
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] All right, let's have a look at a possible solution. First, we had to refactor our data container class. And as you can see, I've replaced all the objects by Ts. And then on line 21, you can see it also specifies the parameterized type, right after the class. Then we need to modify the create string data container method on line 13. We give it a type. This one is creating a string data container, so we specify the type string. And then, we return a new data container, containing the string hello. Let's run this code and see the result. And as you can see, this is the correct answer because we successfully modified the data container class to now have a generic, and then we used this to create one with the type string for the generic and put in the word hello. That's why our test is now succeeding.

Understanding annotations
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] How do you use annotations? You can share your uses for annotations in the Q&A below. I'd love to see all the creative ways you utilize them. Annotations allow us to add metadata to our code. This metadata can be used at compile time or run time to provide additional information or behavior to the Java classes, methods or fields. Let's look at them in more detail. They are a way to associate additional information with classes, methods, or fields, without unintentionally changing their behavior. We can use them for different things, such as generating code, enforcing coding standards, and providing additional context for tools, frameworks and other developers. There are quite a few built-in annotations that we can use in Java. They're quite easy to recognize by the @ sign. Some of the common built-in annotations are the @Override, which indicates that a method is intended to override a method in a superclass. We also have @Deprecated, which marks a method, class, or field as deprecated, indicating that it should not be used anymore. And then there's also @SuppressWarnings. That tells the compiler to suppress specific warnings for a piece of code. Here's an example of them. You can see we have the class 'Student', and I omitted any fields, I just wanted to show you the annotations. Use the @Override on the toString, overriding the toString in the object class. Then we have some sort of method that we mark @Deprecated, and then we have a useUncheckedType method that we use with the @SuppressWarnings annotation. These are examples of annotations or methods, but there's also annotations possible on classes, fields, parameters, etcetera. Frameworks such as Spring Boot and Quarkus rely heavily on annotations as well. They have created a set of annotations that can be used to configure and use the framework. Long story short, annotations are powerful for adding metadata and influencing the behavior of your code at compile time or run time. The built-in annotations are very helpful, but we can also create our own annotations.

Creating custom annotations
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Let's define and use custom annotations in our code. It helps to understand how frameworks like Spring Brute in Java's own annotations are implemented. To create a custom annotation, you'll need to define an annotation type using the @interface keyword. You can then specify the elements' attributes that your annotation will have. That might sound a bit abstract, so here's an example. We defined a custom annotation with two elements here: priority and tags. They both have default value. Default priority is one, and default detect is an empty array. Once we've defined a custom annotation, we can use it in our own code by adding it to classes, methods, fields, just like any built-in annotations. So here we use our custom annotation, and as you can see, we put it on top of the class and on top of the method. Both is possible. On top of the class, we say add my custom annotation, which is the name of our annotation, and we specify a value for the priority and the tags. The one on the method only specifies one for the tags, meaning that it will get the default priority. Creating custom annotations is a whole new tool in our Java Toolbox. Here's another example. We could create custom annotation for data validation such as this one, which is giving a method about whether the email is valid or not. And we could also create one for logging in auditing purposes. You can see this one can only be used on methods because we specified the target of this annotation as a method. Where is the valid email one? It's targeting fields. The annotations become even more useful when you combine them with the Java Reflection API. I'll show you the Reflection API next.

Reflection API for dynamic code manipulation
Selecting transcript lines in this section will navigate to timestamp in the video
- Now that we created custom annotations let's discuss the reflection, API in Java. The reflection API is a built-in Java functionality that allows us to inspect and manipulate our code at run time. The dynamic code manipulation can be used in combination with annotations to achieve interesting results. What do you think I mean by interesting? Reflection is a feature in Java that allows to inspect and interact with the metadata of classes, methods and fields at runtime. With reflection API we can do things like inspect the structure of a class, its methods, fields and annotations. Create new instances of a class, invoke methods and access fields. And even modify the behavior of a class, method or field at runtime. This definitely asks for some examples. So let's see how we can use the reflection API to inspect our custom annotation my custom annotation. So let's go over the steps. On line nine I'm grabbing info.class's data. I'm storing this in a special class object. Just a quick refresher, that's this class info which is having the adds my custom annotation twice, once in the class and once on a method. And yet another refresher, the my custom annotation has a priority and a tax value. So on line 12, we're going to check if the class has our custom annotation. And if that custom annotation is present we are going to go ahead and grab it and then print the priority and print the tags. We're also going to iterate over all the methods in info and then we're going to check for every method whether it's annotated within my custom annotation class. And if that's the case we're going to go ahead, print a method name and also print a value for priority and tags. So let me run this code and show you how this is working. And as you can see, the priority of the class is two and a priority of the method is one, the default value. The value of the tags on the annotation that's on the class are important and feature. On a method the tags are details. So here we used the reflection API to inspect the custom annotation that was applied to the info class and its method. We were able to retrieve the values of the annotations elements and print them. This is why the reflection API is very powerful combined with custom annotations. It's an amazing tool for dynamic code manipulation and it's quite next level Java, and it's going to enable interesting use cases like code generation, dependency injection and runtime configuration. Here's another example of reflection. Here we're actually invoking a method with reflection API. So we're not using annotations here at all. On line seven, we're getting the info class. And then on line eight, we're using reflection API to create an instance of our info class. Then we're going to getting methods on line nine with the getMethod method. And then on line 10, we're using the method object which is part of the reflection API to actually invoke this method on the instance of the info class. As you can imagine, this is also used for testing purposes. Leveraging the combination of annotations and a reflection API is definitely going to improve your Java skills but there's a catch as always. Magic has its price and it's important to use reflection with caution. It can easily lead to performance overhead and potential security risks if not used carefully.

Solution: Custom annotation
Selecting transcript lines in this section will navigate to timestamp in the video
- [Narrator] Alright, let's see the solution for our annotation. So we need to start by implementing the annotation. You can see I'm doing this on line 24 to 28. We create the annotation with the at interface keyword, and then we need to make sure that the element type is method because we need to put this on top of the method and we need it to be maintained during run time. And on line 18, we have a refined answer, and we annotate this with at method description, and then the text finding the answer. So let's go ahead and run this. And as you can see, this is the right solution. You can forget something small though and then it won't work. For example, if I remove the finding the answer, even though the implementation is correct this is not going to work, 'cause we need to specify the value. But also if you are a bit sloppy and you made a typo with the value there, it has to be finding the answer. Otherwise it won't be considered correct. So you can see that when I change it back to finding the answer, our test is going to succeed again. Beneath the surface, it's actually using a reflection API to make sure that the description of the annotation is matching the description that's in the exercise.

Concurrency and multithreading explained
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Concurrency and multithreading are essential concepts in programming. Concurrency enables you to write more efficient and responsive applications. Let's start with explaining what concurrency and multithreading are and why they're so important. Concurrency refers to the ability of a program to manage multiple tasks simultaneously. This can be achieved in various ways, for example, through multithreading. This brings us to the next key concept, multithreading. Multithreading is a specific form of concurrency that involves executing multiple threads. This happens simultaneously within a single process. Threads are lightweight, independent units of execution that can run concurrently, sharing the same memory space. Concurrency allows us to utilize system resources more effectively, leading to improved application performance and responsiveness. Running tasks concurrently will lead to better resource utilization and reduce the time it takes to complete tasks. I always like to explain this with a non code example. Let's say you come home from work after a really busy work week on Friday. You're a bit behind with the household and the kids are hungry. If you are not capable of doing multiple things at the same time, we would do all our tasks sequentially. So first our laundry. When that is done and we've put it out to dry, we would put the pizza in the oven, wait for it to be done, feed the kids, tidy the house and vacuum the floor. This would take a long time. First we have to do laundry which would be one and a half hours. Then wait for the pizza, which is around 20 minutes, feed the kids, again, 20 minutes, tidy the house, also 20 minutes and vacuum the floor, 20 minutes. And that would add up to be two hours and 50 minutes. If we could do it concurrently, we could combine the tasks. We could turn on the laundry machine, put the pizza in the oven, given the electricity can deal with this combination, tidy the house while the pizza is in the oven, feed the kids, vacuum the floor, relax for half an hour and then put the laundry out to dry, and that way, it'll be done in one and a half hour and manage to relax for 30 minutes of the time. This is what Java does too. While waiting for external resources to take care of something, it doesn't sit around and wait, but it does something in the meantime. Java provides built-in support for multithreading to the Java lang thread class and the Java util concurrent package. These classes and interfaces can be used to create and manage threads in our Java applications. Here's an example of how we can actually create a thread. So here we have the MyRunnable class and it implements Runnable, which can be used to start a thread, and we implement the run method. And in the run method, we just print a message and also the thread ID. Then here's our class, MultithreadingExample. And what we're doing right here is that we create a new instance of Runnable and then we start a new thread and pass in the Runnable. Next, we start the thread. Well, let's run this, and as you can see, we get Hello multithreading from thread 15. And just to prove you that this is a different thread, let's start by printing the thread that our main method is using. And I'm going to say Thread.currentThread.getId, like this and I'm going to run it again. And as you can see, the first one is in thread one and then we say hello multithreading from thread number 15. We can go ahead and create a second thread here as well using our Runnable. And then we can start t2 as well. And then let's see if they get different thread numbers. And as you can see, they do. We get hello multithreading from thread number 16 and 15. Which one is which? At this point, there is no real way to tell because it happens simultaneously and we are less sure about the order. So concurrency and multithreading are essential concepts for efficient and responsive Java applications. By understanding these concepts and using Java's built-in support for concurrency can improve the performance and responsiveness of our applications.

Java concepts for concurrency
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Java provides a lot of tools and APIs for working with concurrency and multithreading. We'll explore some of the Java key concepts that you'll need to understand when working with concurrency. Just know that this is going to be a rather high-level overview. First of all, we have the thread class and the runnable interface. These are used for creating a managing threads. The thread class extends the object class and implements the runnable interface, providing methods for starting, stopping, and managing threads. Let's look at an example in IntelliJ. I have created a class MyThread here that extends the thread, and I've overwritten the run methods saying, Hello from thread. And then, I actually print the thread ID. Then, in thread example, I'm using this MyThread twice to create a new thread, and I'm starting this thread as well. So let's go ahead and run this. And you'll probably see two different threads. Now, you can see it says Hello from thread 15 and 16. Please note that, again, these are different threads from my main method. Next, Java provides synchronization and locks to ensure that shared resources are accessed safely and consistently by multiple threads. Without this, we could not be sure that only one thread is using a resource at a given time. The synchronized keyword can be used to create synchronized methods or blocks that allow only one thread at a time to access a shared resource. Here's a simple example of how to do just that. You can see that the method increment on line six has the synchronized keyword in front of it. That means that if multiple threads call the increment method, only one of them is allowed access at the same time. The others will be queued up, waiting for the increment method to become available again. The java.util.concurrent package provides the executor framework, which simplifies the creation and management of threads. Executors are used to create thread pools that can manage the execution of multiple tasks concurrently while reusing the threads in the pool. Again, this might sound a bit fake, so let's have a look at an example. On line eight, I'm using the executor's class to create a fixed thread pool with five threads in it. This creates an object of type ExecutorService. Then we create a runnable task on line nine, and in this task we'll simply print, Hello from Executor on threads, and then print the thread ID again. Then we call the execute method 10 times providing a task, and that's going to execute a task 10 times utilizing the five threads in the thread pool. After that, we close the ExecutorService with the shutdown method. So I'll run this, and you can see what it does. It has different thread IDs. It's 15, 17, 18, 16, and 19 in there. You can see some of them are used multiple times, and some of them are used only once. So let me run this again. You can see it uses different thread IDs this time. The result can be different every time you run this. That's actually most likely because there's different threads and Java manages the task using the five threads from the thread pool. Working with collections and multiple threads can be problematic. Therefore, Java provides a set of concurrent collections in the java.util.concurrent package that are designed for concurrent access and manipulation by multiple threads. These collections include ConcurrentHashMap, ConcurrentLinkedQueue, ConcurrentSkipListSet, and quite a few more. Here's an example of ConcurrentHashMap. As you can see, it looks a lot like a normal map, and that's indeed the case. The main difference here is that it can now be safely manipulated and accessed by multiple threads. Another important concept is how to deal with responses that you don't get right away. The future and callable interfaces provide a way to do exactly this. They represent a managed result of a computation that might not be available immediately. Callable is similar to runnable, but it can return the value. And future represents the result of a computation that might not be available yet. Here's an example. We use an ExecutorService with two threads, and we have a task, and the task involves sleeping for a second. Then we go ahead and submit our task to the ExecutorService, and we store the result in a future with generic type integer. And the next part needs to happen in a try catch block. We do future.get to get the result out, but this may throw an interrupted exception or an execution exception, and that's why we need to do it in a try catch block. We then show the result. In the finally block, we shut down the ExecutorService. Okay, let's run this so you can see how this works. And as you can see, it pauses for a bit, and then prints the result. Let me show this to you again. Pauses, prints the result, and that's because the sleep 1000 isn't there. The gets wait until the future has its result in, and then it prints it. There's multiple ways to get the result. We can also specify how long it can take. So, for example, let's specify for 100 milliseconds, and that's not going to be long enough since we specify that it has to wait for a second in there before it's going to return the result with the Thread.sleep. However, this is a problem because now we also need to catch the timeout exception so let's add it to our list of exceptions here, and let's import the timeout exception, and if we'll run it now, it will timeout, and we'll get in the catch. As you can see, the TimeoutException is now thrown, and as you can also see, it still waits for a little bit until it shuts down, and that's because the ExecutorService that's shut down is going to wait for the task to be done first. There are so many more classes, methods and interfaces and concepts that are great for working with concurrency and multithreading in Java, but this is just a high overview and should be enough to get you started to create applications that can handle multiple tasks simultaneously.

Solution: Implement a concurrent algorithm
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Alright, so this one was a little bit more complex 'cause you had to do a lot of things to get to the answer. Let's start with implementing the factorial task. So here's what you had to do to implement the factorial task class. So I gave it a private final integer number that was going to be used to create a task, so I had to adjust the constructor as well. Then you had to change the implementation of the COLE Method. And in this case the COLE Method's implemented to calculate the factorial, and as you can see, in line 53 we had to return a implementation of the map entry and I went with the abstract map, simple entry. Then we're going to use this callable to actually implement the algorithm. So let's scroll up to the find answer method. You can see it right here. And here's where I'm performing all the logic. So I start by creating an executor service and I give it a fixed thread pool of five. Then I'm working with a list and on this list we have a future and this future consists of a map entry and the map entry is of type integer and big integer. Then we're going to loop over all the numbers in our number array list and we're going to submit them to our execute service by creating a new factorial task. Then afterwards we're going to create the actual map with the results. And in order to populate this map with results we're going to loop over all the futures and get the value out of them and add them to the map. After that, it's very important to shut down your executor, otherwise your code won't stop. And then you return results and then they're ready to be verified. So let's test this code and see the results. And as you can see, these are the expected results. You can now probably tell why we need to use big integers, because these numbers get really, really big. And this calculations like this can be a bit heavy which really benefit from using a concurrent algorithm. So this is just one possible solution. Of course, there is variations possible as well.

Singleton design pattern and its use cases
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] The singleton design pattern is a widely-used creational design pattern, and it ensures that a class has only one instance. Via the singleton class, there will be a global point of access to that instance. The singleton pattern is useful when you need to maintain a shared state or resource throughout your application. It's a very popular design pattern. It's used a lot by frameworks such as Spring Boot. Let's check out the use cases and benefits of the singleton pattern. Here are some typical use cases. First of all, database connections. The singleton pattern can be used to manage a single database connection shared by different parts of an application. Another great one is logger. A global logger that can be accessed and used by multiple components of an application can be created with the singleton pattern. Another very common one is configuration settings. When you want to have a single point of access to application settings, a singleton can be the solution. And there's quite a few benefits that come with using a singleton. First of all, controlled access. The singleton pattern provides controlled access to the single instance, ensuring that no other part of the application can create additional instances. And then there's lazy instantiation. It's not obligated, but a singleton allows for lazy instantiation if you set it up right, which means that the instance is only created when it's needed. And the last major benefit is shared resource management. The singleton pattern ensures that a shared resource or state is managed efficiently and consistently. The singleton design pattern is a popular design pattern that can be used when a class is only allowed to have one instance.

Implementing the Singleton pattern
Selecting transcript lines in this section will navigate to timestamp in the video
- Now that we've discussed use cases and benefits of the singleton design pattern, let's see how to implement it. There are several strategies for implementing the singleton pattern and we'll go over two common approaches, eager initialization and lazy initialization. Eager initialization creates the instance of the singleton class when the class is loaded. This approach is simple and works well when the single instance is not resource intensive or when it's guaranteed to be used during the application's lifetime. And I'm very eager to show you how to do just that. So, here's a eager singleton. As you can see, the class is final, meaning that it's not allowed to have child classes and the constructor is also private, meaning it's not allowed to have child classes. This is an eager singleton because we give a static instance of itself that will recreate at that spot. So, we made the class final to make sure that it cannot be extended. This way, we avoid it having multiple instances. We also have a private constructor to avoid the constructor from being called from the outside. That actually also makes it impossible to extend to class. But to make something else impossible, something that's maybe even more important. And that's because the constructor is private, we cannot call the constructor from outside the class. Again, ensuring that no extra instances of the singleton can be made. We also have lazy initialization. This creates the instance of the singleton class only when it's needed. This approach is more efficient when the singleton instance is resource intensive or when it might not be used during the application's lifetime. And here's how to do it. You can see it's a bit more code. You can see that, in the constructor, we go ahead and check whether the instance is not null. If the instance is not null, yet we are in the constructor, we call the illegal state exception. The get instance method is a little bit more extended right now. If the instance is still no, we go ahead and we create an instance of the singleton lazy class. As you can see, we use the synchronized keyword here to make sure that only one thread at a time can be accessing this. You may wonder why I added the double instance is null check. Well technically, it's possible that two thread are going to both, conclude that it's null and then be queued up for the synchronized block. If that's the case, only the first thread gets to create the instance due to the second's check. This really ensures there's only going to be one instance of the singleton available. There's actually quite some other approaches, but these are the two common ones for implementing the singleton pattern. One of the common critiques to some of the patterns is that when it's used in a multi-threaded environment, it's possible that the instance gets created twice. Even though there's always only one instance available, when two thread called the getInstance at the same time, if this getInstance is not a synchronized method, for example, it's possible that both of them create a new instance when they both conclude the instance is null still. However, at a given time, there will be not more than one value for instance. A synchronized getInstance method can avoid this. And a disadvantage of a synchronized getInstance is that only one thread can access the method and that might be problematic when it's requested by a lot of threads. So, we used a nested double null check combined with synchronized. It's ugly, but it does the trick. Understanding the benefits and drawbacks of each approach can help us choose the best implementation for a specific use case. It's time to get some practice with them now.

Solution: Create a singleton
Selecting transcript lines in this section will navigate to timestamp in the video
- [Instructor] Alright, let's see how to solve this exercise. So we had to implement Singleton. We don't need to change anything in the answer class, so I'm going to scroll down a bit 'cause we had to modify the database connection. So what I've done I've given it an instance of its own type on line 15. And then in the constructor, I'm checking if this instance has been set already. If I somehow end up in the constructor and the instance is not null, I'm throwing an illegal state exception, this should not be possible. Also in the constructor I'm setting my database URL. And then probably the heaviest lifting was to get instance method, 'cause here we have to do some checks and there's multiple ways to get the correct answer because this implementation doesn't require that it also works in a multi-thread environments, but this one should work. So what I'm doing here, I'm first checking if the instance is null, and if that's the case I'm going to synchronize database connection class. So if two threads somehow happen to get in this if statement at the same time, they won't get further both of them, because we're going to synchronize it and then we check again if the instance is null. So the first one to come in there, we'll see that the instance is still null and it will then set the instance. The second one has to wait until the synchronized block is released. And then once it gets in there the instance would no longer be null and it would not create a new instance. At the end, we'll return the instance. So this get instance has been implemented to work in a multi thread environment. So let's see if it works. So we're going to test the code and as you can see, it's the correct answer. When we call the get instance twice, we'll get the same instance because it should only be one instance created over Singleton no matter how often we call the get instance.